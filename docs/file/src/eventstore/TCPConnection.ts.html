<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/eventstore/TCPConnection.ts | eventstore-ts-client | Eventstore typescript / ES6 javascript client lib</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Eventstore typescript / ES6 javascript client lib written in typescript"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="eventstore-ts-client | Eventstore typescript / ES6 javascript client lib"><meta property="twitter:description" content="Eventstore typescript / ES6 javascript client lib written in typescript"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/sebastianwessel/eventstore-ts-client"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#errors">errors</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/errors/EventstoreError.ts~EventstoreError.html">EventstoreError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-newAccessDeniedError">newAccessDeniedError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-newAlreadyExistError">newAlreadyExistError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-newBadRequestError">newBadRequestError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-newCommitTimeoutError">newCommitTimeoutError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-newConnectionError">newConnectionError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-newDoesNotExistError">newDoesNotExistError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-newForwardTimeoutError">newForwardTimeoutError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-newImplementationError">newImplementationError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-newInvalidTransactionError">newInvalidTransactionError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-newNoStreamError">newNoStreamError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-newNotAuthenticatedError">newNotAuthenticatedError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-newNotFoundError">newNotFoundError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-newNotHandledError">newNotHandledError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-newNotModifiedError">newNotModifiedError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-newOperationError">newOperationError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-newPrepareTimeoutError">newPrepareTimeoutError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-newProtocolError">newProtocolError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-newStreamDeletedError">newStreamDeletedError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-newTimeoutError">newTimeoutError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-newUnspecificError">newUnspecificError</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-newWrongExpectedVersionError">newWrongExpectedVersionError</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#event">event</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/event/Event.ts~Event.html">Event</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#eventstore">eventstore</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/eventstore/Eventstore.ts~Eventstore.html">Eventstore</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/eventstore/Position.ts~Position.html">Position</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/eventstore/TCPConnection.ts~TCPConnection.html">TCPConnection</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-setConnectionSettings">setConnectionSettings</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-fetchgossipJson">fetchgossipJson</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getIpAndPort">getIpAndPort</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getIpListFromDns">getIpListFromDns</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getMasterNodeInfo">getMasterNodeInfo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getRandomNodeInfo">getRandomNodeInfo</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#protobuf">protobuf</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-uuidFromBuffer">uuidFromBuffer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-uuidToBuffer">uuidToBuffer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-$root">$root</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#stream">stream</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/stream/Stream.ts~Stream.html">Stream</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/stream/Transaction.ts~Transaction.html">Transaction</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#subscription">subscription</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/subscription/PersitentSubscription.ts~PersitentSubscription.html">PersitentSubscription</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/subscription/Subscription.ts~Subscription.html">Subscription</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-setPersitentSubscriptionConfig">setPersitentSubscriptionConfig</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-SystemConsumerStrategies">SystemConsumerStrategies</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/eventstore/TCPConnection.ts</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import {EventstoreSettings} from &apos;./EventstoreSettings&apos;
import * as net from &apos;net&apos;
import * as tls from &apos;tls&apos;
import * as bunyan from &apos;bunyan&apos;
import {EventEmitter} from &apos;events&apos;
import {uuidToBuffer, uuidFromBuffer} from &apos;../protobuf/uuidBufferConvert&apos;
import {EventstoreCommand} from &apos;../protobuf/EventstoreCommand&apos;
import * as eventstoreError from &apos;../errors&apos;
import * as model from &apos;../protobuf/model&apos;
import {Subscription} from &apos;../subscription&apos;
import {Stream} from &apos;../stream&apos;
import {UserCredentials} from &apos;../eventstore/EventstoreSettings&apos;
import uuid = require(&apos;uuid/v4&apos;)
import {Event} from &apos;../event&apos;
import {getIpAndPort} from &apos;./getConnectInfo&apos;
import {Position} from &apos;./Position&apos;

const protobuf = model.eventstore.proto

/** typescript enumeration of connection states */
enum connectionState {
  closed,
  init,
  connected,
  drain
}

/** raw tcp communication constant */
const FLAGS_NONE = 0x00
/** raw tcp communication constant */
const FLAGS_AUTH = 0x01
/** raw tcp communication constant */
const UINT32_LENGTH = 4
/** raw tcp communication constant */
const GUID_LENGTH = 16
/** raw tcp communication constant */
const HEADER_LENGTH = 1 + 1 + GUID_LENGTH // Cmd + Flags + CorrelationId
/** raw tcp communication constant */
const COMMAND_OFFSET = UINT32_LENGTH
/** raw tcp communication constant */
const FLAGS_OFFSET = COMMAND_OFFSET + 1
/** raw tcp communication constant */
const CORRELATION_ID_OFFSET = FLAGS_OFFSET + 1
/** raw tcp communication constant */
const DATA_OFFSET = CORRELATION_ID_OFFSET + GUID_LENGTH // Length + Cmd + Flags + CorrelationId

/**
 * Raw tcp communication to eventstore
 * This class handles basic communication with eventstore
 *
 * @export
 * @class TCPConnection
 * @extends {EventEmitter}
 * @emits {error} emit error on connection errors
 * @emits {heartbeat} emit incoming heartbeat
 * @emits {connected} emit when connection is established
 * @emits {close} emit when connection is closed
 * @emits {drain} emit before connection closes
 *
 */
export class TCPConnection extends EventEmitter {
  protected initialConfig: EventstoreSettings
  protected connectionConfig: EventstoreSettings
  protected socket: net.Socket | tls.TLSSocket
  protected connectionId: string | null = null
  protected pendingRequests: Map&lt;string, {resolve: Function; reject: Function}&gt; = new Map()
  public log: bunyan
  protected state: connectionState = connectionState.closed
  protected messageCurrentOffset: number = 0
  protected messageCurrentLength: number = 0
  protected messageData: Buffer | null = null
  protected subscriptionList: Map&lt;string, Subscription&gt; = new Map()
  protected isUnexpectedClosed: boolean = true
  protected heartBeatCheckInterval: NodeJS.Timeout | null = null
  protected lastHeartBeatTime: number

  /**
   *Creates an instance of TCPConnection.
   * @param {EventstoreSettings} connectionConfiguration
   * @memberof TCPConnection
   */
  public constructor(connectionConfiguration: EventstoreSettings) {
    super()
    this.initialConfig = {...connectionConfiguration}
    this.connectionConfig = connectionConfiguration
    this.log = this.connectionConfig.logger.child
      ? this.connectionConfig.logger.child({module: &apos;TCPConnection&apos;})
      : this.connectionConfig.logger

    this.socket = new net.Socket()

    this.lastHeartBeatTime = Date.now()
  }

  /**
   * Returns true if connected to eventstore otherwise false
   *
   * @readonly
   * @type {boolean}
   * @memberof TCPConnection
   */
  public get isConnected(): boolean {
    return this.state === connectionState.connected
  }

  /**
   * Connect to eventstore
   *
   * @returns {Promise&lt;void&gt;}
   * @memberof TCPConnection
   */
  public async connect(): Promise&lt;void&gt; {
    this.state = connectionState.init

    this.connectionConfig = await getIpAndPort({...this.initialConfig}, this.log)

    const port = this.connectionConfig.port
    const host = this.connectionConfig.host

    if (port === 0 || host === &apos;&apos;) {
      throw eventstoreError.newConnectionError(&apos;Invalid connection settings on host and port&apos;)
    }

    this.log.debug(`Start connecting to ${host}:${port}`)

    await new Promise(
      (resolve, reject): void =&gt; {
        const errorListener = (err: Error): void =&gt; {
          this.state = connectionState.closed
          this.onError(eventstoreError.newConnectionError(err.message, err))
          reject(err)
        }

        const successListener = (): void =&gt; {
          if (this.socket instanceof tls.TLSSocket) {
            if (!this.socket.authorized) {
              this.log.warn({err: this.socket.authorizationError}, &apos;SSL authorization warning&apos;)
            }
          }
          this.socket.removeListener(&apos;error&apos;, errorListener)
          this.socket.on(&apos;error&apos;, this.onError.bind(this))
          this.onConnect()
          this.heartBeatCheckInterval = setInterval((): void =&gt; {
            if (this.lastHeartBeatTime + this.connectionConfig.heartbeatTimeout &lt; Date.now()) {
              const err = eventstoreError.newTimeoutError(
                `Heartbeat missing more than ${this.connectionConfig.heartbeatTimeout}ms`
              )
              this.onError(err)
            }
          }, this.connectionConfig.heartbeatInterval)
          resolve()
          this.isUnexpectedClosed = false
        }

        if (this.connectionConfig.useSSL) {
          let secureContext
          if (this.connectionConfig.secureContext) {
            try {
              secureContext = tls.createSecureContext(this.connectionConfig.secureContext)
            } catch (err) {
              const conErr = eventstoreError.newConnectionError(
                &apos;Error creating secure context&apos;,
                err
              )
              reject(conErr)
            }
          }

          const options = {
            port,
            host,
            servername: host,
            requestCert: this.connectionConfig.validateServer,
            rejectUnauthorized: this.connectionConfig.validateServer,
            timeout: this.connectionConfig.connectTimeout,
            secureContext
          }

          this.socket = tls.connect(options, successListener)
        } else {
          const options = {
            port,
            host,
            servername: host,
            timeout: this.connectionConfig.connectTimeout
          }
          this.socket = net.connect(options, successListener)
        }

        this.socket.once(&apos;error&apos;, errorListener.bind(this))
        this.socket.on(&apos;close&apos;, this.onClose.bind(this))
        this.socket.on(&apos;data&apos;, this.onData.bind(this))
        this.socket.on(&apos;secureConnect&apos;, this.onSecureConnect.bind(this))
      }
    )
  }

  /**
   * Disconnect from eventstore.
   * It tries to drain pending queue to prevent data loose before connection gets closed
   * If disconnect() is call no new outgoing requests accepted
   *
   * @returns {Promise&lt;void&gt;}
   * @memberof TCPConnection
   */
  public async disconnect(): Promise&lt;void&gt; {
    if (!this.isConnected) {
      return
    }
    if (this.heartBeatCheckInterval) {
      clearInterval(this.heartBeatCheckInterval)
    }
    await new Promise(
      (resolve, reject): void =&gt; {
        this.onDrain()
        if (this.pendingRequests.size &lt;= 0) {
          this.state = connectionState.closed
          this.isUnexpectedClosed = false
          this.socket.end(
            (): void =&gt; {
              this.socket.destroy()
              resolve()
            }
          )
        } else {
          setTimeout((): void =&gt; {
            this.state = connectionState.closed
            this.isUnexpectedClosed = false
            if (this.pendingRequests.size &gt; 0) {
              this.socket.end(
                (): void =&gt; {
                  this.socket.destroy()
                  const err = eventstoreError.newConnectionError(
                    `Lost ${this.pendingRequests.size} answers`
                  )
                  reject(err)
                  this.onError(err)
                }
              )
            } else {
              this.socket.end(
                (): void =&gt; {
                  this.socket.destroy()
                  resolve()
                }
              )
            }
          }, 10000)
        }
      }
    )
  }

  /**
   * Creates and sends raw data message to eventstore and adds given promise to pending queue
   *
   * @param {string} correlationId
   * @param {EventstoreCommand} command
   * @param {?Buffer)} [data=null]
   * @param {?(UserCredentials)} [credentials=null]
   * @param {(?{resolve: Function; reject: Function})} [promise=null]
   * @memberof TCPConnection
   */
  public sendCommand(
    correlationId: string,
    command: EventstoreCommand,
    data: Buffer | null = null,
    credentials: UserCredentials | null = null,
    promise: {resolve: Function; reject: Function} | null = null
  ): void {
    this.log.trace(`Sending ${EventstoreCommand[command]} with ${correlationId}`)
    if (
      this.state !== connectionState.connected &amp;&amp;
      command !== EventstoreCommand.HeartbeatResponseCommand &amp;&amp;
      command !== EventstoreCommand.Pong
    ) {
      throw eventstoreError.newConnectionError(
        &apos;Connection to eventstore is: &apos; + connectionState[this.state]
      )
    }

    if (promise) {
      if (this.pendingRequests.size &gt;= this.connectionConfig.maxConcurrentItems) {
        throw eventstoreError.newConnectionError(&apos;Maximum concurrent items reached&apos;)
      }
      this.pendingRequests.set(correlationId, promise)
    }

    try {
      let authLength = 0
      let flags = FLAGS_NONE
      if (credentials) {
        flags = FLAGS_AUTH
        authLength = 1 + credentials.username.length + 1 + credentials.password.length
      }

      let commandLength = HEADER_LENGTH + authLength
      if (data) {
        commandLength += data.length
      }
      const packetLength = 4 + commandLength

      const buf = Buffer.alloc(packetLength)
      buf.writeUInt32LE(commandLength, 0)
      buf[COMMAND_OFFSET] = command
      buf[FLAGS_OFFSET] = flags

      uuidToBuffer(correlationId).copy(buf, CORRELATION_ID_OFFSET, 0, GUID_LENGTH)
      if (credentials) {
        buf.writeUInt8(credentials.username.length, DATA_OFFSET)
        buf.write(credentials.username, DATA_OFFSET + 1)
        buf.writeUInt8(credentials.password.length, DATA_OFFSET + 1 + credentials.username.length)
        buf.write(credentials.password, DATA_OFFSET + 1 + credentials.username.length + 1)
      }

      if (data) {
        data.copy(buf, DATA_OFFSET + authLength, 0, data.length)
      }

      this.socket.write(buf)
    } catch (err) {
      const newErr = eventstoreError.newConnectionError(err.message, err)
      this.rejectCommandPromise(correlationId, newErr)
      this.onError(newErr)
    }
  }

  /**
   * Gets called as soon as new data over tcp connection arrives as raw buffer data
   * Checks if
   * - new received data is part of previously received data
   * - new data contains multiple responses
   * - new data is single response
   *
   * @protected
   * @param {Buffer} data
   * @returns {(Buffer | null)}
   * @memberof TCPConnection
   */
  protected handleNewResponseData(data: Buffer): Buffer | null {
    const commandLength = data.readUInt32LE(0)
    if (commandLength &lt; HEADER_LENGTH) {
      this.log.error(
        {
          connectionId: this.connectionId,
          fn: &apos;handleNewResponseData&apos;
        },
        &apos;Invalid command length of &apos; + commandLength + &apos; bytes&apos;
      )
      throw eventstoreError.newProtocolError(&apos;Invalid command length&apos;)
    }

    const messageLength = UINT32_LENGTH + commandLength
    if (data.length === messageLength) {
      // A single packet message, no need to copy into another buffer
      this.handleSingleResponseData(data)
      return null
    } else if (data.length &gt; messageLength) {
      // Multiple messages in one packet
      const firstMessage = data.slice(0, messageLength)
      this.messageCurrentLength = messageLength
      this.handleSingleResponseData(firstMessage)
      return data.slice(this.messageCurrentLength)
    } else {
      // The first packet of a multi-packet message
      this.messageData = Buffer.alloc(messageLength)
      const packetLength = data.copy(this.messageData, this.messageCurrentOffset, 0)
      this.messageCurrentOffset = packetLength
      return null
    }
  }

  /**
   * This function handles raw buffer responses received within multiple tcp data package
   *
   * @protected
   * @param {Buffer} data
   * @returns {(Buffer | null)}
   * @memberof TCPConnection
   */
  protected handleMultiPacketResponseData(data: Buffer): Buffer | null {
    this.log.debug({fn: &apos;handleMultiPacketResponseData&apos;}, `MultipacketResponse`)
    if (this.messageData === null) {
      return null
    }
    const packetLength = data.copy(this.messageData, this.messageCurrentOffset, 0)
    this.messageCurrentOffset += packetLength
    if (this.messageCurrentOffset &gt;= this.messageData.length) {
      this.handleSingleResponseData(this.messageData)
      this.messageData = null
      this.messageCurrentOffset = 0
    }
    return null
  }

  /**
   * This function handles a single raw buffer response
   *
   * @protected
   * @param {Buffer} data
   * @emits {heartbeat}
   * @memberof TCPConnection
   */
  protected handleSingleResponseData(data: Buffer): void {
    const commandLength = data.readUInt32LE(0)
    if (commandLength &lt; HEADER_LENGTH) {
      this.log.error(
        {
          connectionId: this.connectionId,
          fn: &apos;handleSingleResponseData&apos;
        },
        &apos;Invalid command length of &apos; + commandLength + &apos; bytes&apos;
      )
      throw eventstoreError.newProtocolError(&apos;Invalid command length&apos;)
    }

    const command = data[COMMAND_OFFSET]

    const correlationId = uuidFromBuffer(
      data.slice(CORRELATION_ID_OFFSET, CORRELATION_ID_OFFSET + GUID_LENGTH)
    )

    this.log.trace(&apos;Incoming response: &apos; + EventstoreCommand[command])

    //Answer Heartbeat directly without adding to promise queue
    if (command === EventstoreCommand.HeartbeatRequestCommand) {
      this.emit(&apos;heartbeat&apos;)
      this.sendCommand(correlationId, EventstoreCommand.HeartbeatResponseCommand)
      return
    }

    //Answer Ping directly without adding to promise queue
    if (command === EventstoreCommand.Ping) {
      this.sendCommand(correlationId, EventstoreCommand.Pong)
      return
    }

    const payloadLength = commandLength - HEADER_LENGTH
    const payload = Buffer.alloc(payloadLength)
    if (payloadLength &gt; 0) {
      data.copy(payload, 0, DATA_OFFSET, DATA_OFFSET + payloadLength)
    }

    let err: eventstoreError.EventstoreError
    switch (command) {
      case EventstoreCommand.BadRequest:
        err = eventstoreError.newBadRequestError()
        this.rejectCommandPromise(correlationId, err)
        this.onError(err)
        break
      case EventstoreCommand.NotAuthenticated:
        err = eventstoreError.newNotAuthenticatedError()
        this.rejectCommandPromise(correlationId, err)
        this.onError(err)
        break
      case EventstoreCommand.NotHandled:
        const notHandled = protobuf.NotHandled.decode(payload)
        err = eventstoreError.newNotHandledError(`
          ${protobuf.NotHandled.NotHandledReason[notHandled.reason]}
        `)
        this.rejectCommandPromise(correlationId, err)
        this.onError(err)
        break
      case EventstoreCommand.CreatePersistentSubscriptionCompleted:
        this.handleCreatePersistentSubscriptionCompleted(correlationId, payload)
        break
      case EventstoreCommand.DeletePersistentSubscriptionCompleted:
        this.handleDeletePersistentSubscriptionCompleted(correlationId, payload)
        break
      case EventstoreCommand.DeleteStreamCompleted:
        this.handleDeleteStreamCompleted(correlationId, payload)
        break
      case EventstoreCommand.PersistentSubscriptionConfirmation:
        this.handlePersistentSubscriptionConfirmation(correlationId, payload)
        break
      case EventstoreCommand.PersistentSubscriptionStreamEventAppeared:
        this.handlePersistentSubscriptionStreamEventAppeared(correlationId, payload)
        break

      case EventstoreCommand.ReadAllEventsBackwardCompleted:
        this.handleReadAllEventsCompleted(correlationId, payload)
        break
      case EventstoreCommand.ReadAllEventsForwardCompleted:
        this.handleReadAllEventsCompleted(correlationId, payload)
        break

      case EventstoreCommand.ReadEventCompleted:
        this.handleReadEventCompleted(correlationId, payload)
        break

      case EventstoreCommand.ReadStreamEventsBackwardCompleted:
        this.handleReadStreamEventsCompleted(correlationId, payload)
        break
      case EventstoreCommand.ReadStreamEventsForwardCompleted:
        this.handleReadStreamEventsCompleted(correlationId, payload)
        break
      /*
      case EventstoreCommand.ScavengeDatabaseCompleted:
        this.handleScavengeDatabaseResponse(correlationId, payload)
        break
*/
      case EventstoreCommand.StreamEventAppeared:
        this.handleStreamEventAppeared(correlationId, payload)
        break
      case EventstoreCommand.SubscriptionConfirmation:
        this.handleSubscriptionConfirmation(correlationId, payload)
        break
      case EventstoreCommand.SubscriptionDropped:
        this.handleSubscriptionDropped(correlationId, payload)
        break
      case EventstoreCommand.TransactionCommitCompleted:
        this.handleTransactionCommitCompleted(correlationId, payload)
        break
      case EventstoreCommand.TransactionStartCompleted:
        this.handleTransactionStartCompleted(correlationId, payload)
        break
      case EventstoreCommand.TransactionWriteCompleted:
        this.handleTransactionWriteCompleted(correlationId, payload)
        break
      case EventstoreCommand.UpdatePersistentSubscriptionCompleted:
        this.handleUpdatePersistentSubscriptionCompleted(correlationId, payload)
        break
      case EventstoreCommand.WriteEventsCompleted:
        this.handleWriteEventsCompleted(correlationId, payload)
        break
      case EventstoreCommand.ClientIdentified:
        this.resolveCommandPromise(correlationId)
        break
      case EventstoreCommand.Pong:
        this.resolveCommandPromise(correlationId)
        break
      case EventstoreCommand.Authenticated:
        this.resolveCommandPromise(correlationId)
        break
      default:
        err = new eventstoreError.EventstoreError(
          &apos;Unhandled eventstore command : &apos; + EventstoreCommand[command] + &apos; -&gt; &apos; + command,
          &apos;EventstoreImplementationError&apos;
        )
        this.rejectCommandPromise(correlationId, err)
        this.onError(err)
        break
    }
  }

  /**
   * Handle response for command CreatePersistentSubscription
   *
   * @protected
   * @param {string} correlationId
   * @param {Buffer} payload
   * @memberof TCPConnection
   */
  protected handleCreatePersistentSubscriptionCompleted(
    correlationId: string,
    payload: Buffer
  ): void {
    const decoded = protobuf.CreatePersistentSubscriptionCompleted.decode(payload)
    if (
      decoded.result ===
      protobuf.CreatePersistentSubscriptionCompleted.CreatePersistentSubscriptionResult.Success
    ) {
      this.resolveCommandPromise(correlationId)
    } else {
      const errorMsg =
        `${
          protobuf.CreatePersistentSubscriptionCompleted.CreatePersistentSubscriptionResult[
            decoded.result
          ]
        } ` + (decoded.reason || &apos;&apos;)
      let err
      switch (decoded.result) {
        case protobuf.CreatePersistentSubscriptionCompleted.CreatePersistentSubscriptionResult
          .AccessDenied:
          err = eventstoreError.newAccessDeniedError(errorMsg)
          break
        case protobuf.CreatePersistentSubscriptionCompleted.CreatePersistentSubscriptionResult
          .AlreadyExists:
          err = eventstoreError.newAlreadyExistError(errorMsg)
          break
        default:
          err = eventstoreError.newUnspecificError(errorMsg)
      }
      this.rejectCommandPromise(correlationId, err)
    }
  }

  /**
   * Handle response for command DeletePersistentSubscription
   *
   * @protected
   * @param {string} correlationId
   * @param {Buffer} payload
   * @memberof TCPConnection
   */
  protected handleDeletePersistentSubscriptionCompleted(
    correlationId: string,
    payload: Buffer
  ): void {
    const decoded = protobuf.DeletePersistentSubscriptionCompleted.decode(payload)
    if (
      decoded.result ===
      protobuf.DeletePersistentSubscriptionCompleted.DeletePersistentSubscriptionResult.Success
    ) {
      this.resolveCommandPromise(correlationId)
    } else {
      const err = new eventstoreError.EventstoreError(
        `${
          protobuf.DeletePersistentSubscriptionCompleted.DeletePersistentSubscriptionResult[
            decoded.result
          ]
        } ` + (decoded.reason || &apos;&apos;),
        &apos;EventstoreDeletePersistentSubscriptionError&apos;
      )
      this.rejectCommandPromise(correlationId, err)
    }
  }

  /**
   * Handle response for command DeleteStreamCompleted
   *
   * @protected
   * @param {string} correlationId
   * @param {Buffer} payload
   * @memberof TCPConnection
   */
  protected handleDeleteStreamCompleted(correlationId: string, payload: Buffer): void {
    const decoded = protobuf.DeleteStreamCompleted.decode(payload)
    if (this.checkOperationResult(correlationId, decoded.result, decoded.message)) {
      this.resolveCommandPromise(correlationId)
    }
  }

  /**
   * Handle response for command ReadAllEvents
   *
   * @protected
   * @param {string} correlationId
   * @param {Buffer} payload
   * @memberof TCPConnection
   */
  protected handleReadAllEventsCompleted(correlationId: string, payload: Buffer): void {
    const decoded = protobuf.ReadAllEventsCompleted.decode(payload)
    let err: eventstoreError.EventstoreError
    const message: string = decoded.error || &apos;&apos;
    switch (decoded.result) {
      case protobuf.ReadAllEventsCompleted.ReadAllResult.Success:
        this.resolveCommandPromise(correlationId, decoded)
        return
        break
      case protobuf.ReadAllEventsCompleted.ReadAllResult.AccessDenied:
        err = eventstoreError.newAccessDeniedError(message)
        break
      case protobuf.ReadAllEventsCompleted.ReadAllResult.NotModified:
        err = eventstoreError.newNotModifiedError(message)
        break
      default:
        err = eventstoreError.newUnspecificError(message)
    }
    this.rejectCommandPromise(correlationId, err)
  }

  /**
   * Handle response for command ReadStreamEvents
   *
   * @protected
   * @param {string} correlationId
   * @param {Buffer} payload
   * @memberof TCPConnection
   */
  protected handleReadStreamEventsCompleted(correlationId: string, payload: Buffer): void {
    const decoded = protobuf.ReadStreamEventsCompleted.decode(payload)
    let err: eventstoreError.EventstoreError
    const message: string = decoded.error || &apos;&apos;
    switch (decoded.result) {
      case protobuf.ReadStreamEventsCompleted.ReadStreamResult.Success:
        this.resolveCommandPromise(correlationId, decoded)
        return
        break
      case protobuf.ReadStreamEventsCompleted.ReadStreamResult.NoStream:
        err = eventstoreError.newNoStreamError(message)
        break
      case protobuf.ReadStreamEventsCompleted.ReadStreamResult.NotModified:
        err = eventstoreError.newNotModifiedError(message)
        break
      case protobuf.ReadStreamEventsCompleted.ReadStreamResult.StreamDeleted:
        err = eventstoreError.newStreamDeletedError(message)
        break
      case protobuf.ReadStreamEventsCompleted.ReadStreamResult.AccessDenied:
        err = eventstoreError.newAccessDeniedError(message)
        break

      default:
        err = eventstoreError.newUnspecificError(message)
    }
    this.rejectCommandPromise(correlationId, err)
  }

  /**
   * Handle response for command ReadEvent
   *
   * @protected
   * @param {string} correlationId
   * @param {Buffer} payload
   * @memberof TCPConnection
   */
  protected handleReadEventCompleted(correlationId: string, payload: Buffer): void {
    const decoded = protobuf.ReadEventCompleted.decode(payload)

    let err: eventstoreError.EventstoreError
    const message: string = decoded.error || &apos;&apos;
    switch (decoded.result) {
      case protobuf.ReadEventCompleted.ReadEventResult.Success:
        this.resolveCommandPromise(correlationId, decoded.event)
        return
        break
      case protobuf.ReadEventCompleted.ReadEventResult.NotFound:
        err = eventstoreError.newNotFoundError(message)
        break
      case protobuf.ReadEventCompleted.ReadEventResult.NoStream:
        err = eventstoreError.newNoStreamError(message)
        break
      case protobuf.ReadEventCompleted.ReadEventResult.StreamDeleted:
        err = eventstoreError.newStreamDeletedError(message)
        break
      case protobuf.ReadEventCompleted.ReadEventResult.AccessDenied:
        err = eventstoreError.newAccessDeniedError(message)
        break
      default:
        err = eventstoreError.newUnspecificError(message)
    }
    this.rejectCommandPromise(correlationId, err)
  }

  /*
  Commented out because currently not supportet by eventstore over tcp
  protected handleScavengeDatabaseResponse(correlationId: string, payload: Buffer): void {
    const decoded = protobuf.ScavengeDatabaseResponse.decode(payload)
    if ((decoded.result = protobuf.ScavengeDatabaseResponse.ScavengeResult.Unauthorized)) {
      const err = eventstoreError.newAccessDeniedError(&apos;Unauthorized to scavenge database&apos;)
      this.rejectCommandPromise(correlationId, err)
      return
    }

    this.resolveCommandPromise(correlationId, decoded)
  }
  */

  /**
   * Handle incoming event for subscription
   *
   * @protected
   * @param {string} correlationId
   * @param {Buffer} payload
   * @memberof TCPConnection
   */
  protected handleStreamEventAppeared(correlationId: string, payload: Buffer): void {
    const decoded = protobuf.StreamEventAppeared.decode(payload)
    const subscription = this.subscriptionList.get(correlationId)
    if (subscription) {
      let event
      if (decoded.event.event) {
        event = Event.fromRaw(decoded.event.event)
      } else if (decoded.event.link) {
        event = Event.fromRaw(decoded.event.link)
      } else {
        subscription.emit(
          &apos;error&apos;,
          eventstoreError.newProtocolError(
            &apos;Received stream event with empty event and empty link field&apos;
          )
        )
        return
      }
      subscription.emit(
        &apos;event&apos;,
        event,
        new Position(decoded.event.commitPosition, decoded.event.preparePosition)
      )
      subscription.emit(
        `event-${event.name.toLocaleLowerCase()}`,
        event,
        new Position(decoded.event.commitPosition, decoded.event.preparePosition)
      )
    } else {
      this.log.error({subscriptionId: correlationId}, &apos;Received StreamEventAppeared for unknown id&apos;)
      this.emit(
        &apos;error&apos;,
        eventstoreError.newImplementationError(
          `Received StreamEventAppeared for unknown id ${correlationId}`
        )
      )
    }
  }

  /**
   * Handle response for command Subscription
   *
   * @protected
   * @param {string} correlationId
   * @param {Buffer} payload
   * @memberof TCPConnection
   */
  protected handleSubscriptionConfirmation(correlationId: string, payload: Buffer): void {
    const decoded = protobuf.SubscriptionConfirmation.decode(payload)

    this.resolveCommandPromise(correlationId, {
      subscriptionId: correlationId,
      lastCommitPosition: decoded.lastCommitPosition,
      lastEventNumber: decoded.lastEventNumber
    })
  }

  /**
   * Handle subscription drop
   *
   * @protected
   * @param {string} correlationId
   * @param {Buffer} payload
   * @memberof TCPConnection
   */
  protected handleSubscriptionDropped(correlationId: string, payload: Buffer): void {
    const decoded = protobuf.SubscriptionDropped.decode(payload)
    const subscription = this.subscriptionList.get(correlationId) || null
    if (subscription) {
      subscription.emit(&apos;dropped&apos;, decoded.reason)
    }
    if (this.pendingRequests.has(correlationId)) {
      this.resolveCommandPromise(correlationId, decoded)
    }
  }

  /**
   * Handle response for command TransactionCommit
   *
   * @protected
   * @param {string} correlationId
   * @param {Buffer} payload
   * @memberof TCPConnection
   */
  protected handleTransactionCommitCompleted(correlationId: string, payload: Buffer): void {
    const decoded = protobuf.TransactionCommitCompleted.decode(payload)
    if (this.checkOperationResult(correlationId, decoded.result, decoded.message)) {
      this.resolveCommandPromise(correlationId, decoded)
    }
  }

  /**
   * Handle response for command TransactionStart
   *
   * @protected
   * @param {string} correlationId
   * @param {Buffer} payload
   * @memberof TCPConnection
   */
  protected handleTransactionStartCompleted(correlationId: string, payload: Buffer): void {
    const decoded = protobuf.TransactionStartCompleted.decode(payload)
    if (this.checkOperationResult(correlationId, decoded.result, decoded.message)) {
      this.resolveCommandPromise(correlationId, decoded.transactionId)
    }
  }

  /**
   * Handles transaction write completed
   * @param correlationId
   * @param payload
   */
  protected handleTransactionWriteCompleted(correlationId: string, payload: Buffer): void {
    const decoded = protobuf.TransactionWriteCompleted.decode(payload)
    if (this.checkOperationResult(correlationId, decoded.result, decoded.message)) {
      this.resolveCommandPromise(correlationId, decoded.transactionId)
    }
  }

  /**
   * Handles update persistent subscription completed
   * @param correlationId
   * @param payload
   */
  protected handleUpdatePersistentSubscriptionCompleted(
    correlationId: string,
    payload: Buffer
  ): void {
    const decoded = protobuf.UpdatePersistentSubscriptionCompleted.decode(payload)
    const status = protobuf.UpdatePersistentSubscriptionCompleted.UpdatePersistentSubscriptionResult
    const message = decoded.reason || &apos;&apos;
    switch (decoded.result) {
      case status.Success:
        this.resolveCommandPromise(correlationId)
        break
      case status.DoesNotExist:
        this.rejectCommandPromise(correlationId, eventstoreError.newDoesNotExistError(message))
        break
      case status.AccessDenied:
        this.rejectCommandPromise(correlationId, eventstoreError.newAccessDeniedError(message))
        break
      default:
    }
  }

  /**
   * Handles write events completed
   * @param correlationId
   * @param payload
   */
  protected handleWriteEventsCompleted(correlationId: string, payload: Buffer): void {
    const decoded = protobuf.WriteEventsCompleted.decode(payload)
    if (this.checkOperationResult(correlationId, decoded.result, decoded.message)) {
      this.resolveCommandPromise(correlationId, decoded)
    }
  }

  /**
   * Handles persistent subscription confirmation
   * @param correlationId
   * @param payload
   */
  protected handlePersistentSubscriptionConfirmation(correlationId: string, payload: Buffer): void {
    const decoded = protobuf.PersistentSubscriptionConfirmation.decode(payload)
    this.resolveCommandPromise(correlationId, decoded)
  }

  /**
   * Handles persistent subscription stream event appeared
   * @param correlationId
   * @param payload
   */
  protected handlePersistentSubscriptionStreamEventAppeared(
    correlationId: string,
    payload: Buffer
  ): void {
    /*TODO*/
  }

  /**
   * CHecks if given result is an error code
   * It returns true for successful result otherwise it returns false.
   * If result is an error this function rejectes corresponding command promise and remove it from command queue
   *
   * @protected
   * @param {string} correlationId
   * @param {number} result
   * @param {string} [message=&apos;&apos;]
   * @returns {boolean}
   * @memberof TCPConnection
   */
  protected checkOperationResult(
    correlationId: string,
    result: number,
    message: string = &apos;&apos;
  ): boolean {
    let err: eventstoreError.EventstoreError
    switch (result) {
      case protobuf.OperationResult.Success:
        return true
        break
      case protobuf.OperationResult.AccessDenied:
        err = eventstoreError.newAccessDeniedError(message)
        break
      case protobuf.OperationResult.CommitTimeout:
        err = eventstoreError.newCommitTimeoutError(message)
        break
      case protobuf.OperationResult.ForwardTimeout:
        err = eventstoreError.newForwardTimeoutError(message)
        break
      case protobuf.OperationResult.InvalidTransaction:
        err = eventstoreError.newInvalidTransactionError(message)
        break
      case protobuf.OperationResult.PrepareTimeout:
        err = eventstoreError.newPrepareTimeoutError(message)
        break
      case protobuf.OperationResult.StreamDeleted:
        err = eventstoreError.newStreamDeletedError(message)
        break
      case protobuf.OperationResult.WrongExpectedVersion:
        err = eventstoreError.newWrongExpectedVersionError(message)
        break
      default:
        err = eventstoreError.newUnspecificError(&apos;Invalid operation result&apos;)
        break
    }
    this.rejectCommandPromise(correlationId, err)
    return false
  }

  /**
   * Will be called if a command send to eventstore was replied with an error
   * In this case corresponding promise will be rejected and removed from queue
   *
   * @protected
   * @param {string} correlationId
   * @param {eventstoreError.EventstoreError} error
   * @memberof TCPConnection
   */
  protected rejectCommandPromise(
    correlationId: string,
    error: eventstoreError.EventstoreError
  ): void {
    const resultPromise = this.pendingRequests.get(correlationId)
    if (resultPromise) {
      resultPromise.reject(error)
      this.pendingRequests.delete(correlationId)
    } else {
      const err = eventstoreError.newImplementationError(
        `Could not find correlationId ${correlationId} on rejectCommandPromise`
      )
      this.onError(err)
    }
  }

  /**
   * Will be called if a command send to eventstore was replied with success response
   * In this case corresponding promise will be resolved with result received from eventstore
   *
   * @protected
   * @param {string} correlationId
   * @param {(null | T)} [result=null]
   * @memberof TCPConnection
   */
  protected resolveCommandPromise&lt;T&gt;(correlationId: string, result: null | T = null): void {
    const resultPromise = this.pendingRequests.get(correlationId)
    if (resultPromise) {
      resultPromise.resolve(result)
      this.pendingRequests.delete(correlationId)
    } else {
      const err = eventstoreError.newImplementationError(
        `Could not find correlationId ${correlationId} on resolveCommandPromise`
      )
      this.onError(err)
    }
  }

  /**
   * Subscribes to stream
   * @param stream
   * @param [resolveLinkTos]
   * @param credentials
   * @returns to stream
   */
  public subscribeToStream(
    stream: Stream,
    resolveLinkTos: boolean = true,
    credentials: UserCredentials | null
  ): Promise&lt;Subscription&gt; {
    const newSubscription = new Subscription(uuid(), this, stream, resolveLinkTos, credentials)
    this.subscriptionList.set(newSubscription.id, newSubscription)
    return new Promise(
      (resolve, reject): void =&gt; {
        const resolveFunction = (): void =&gt; {
          newSubscription.isSubscribed = true
          newSubscription.emit(&apos;subscribed&apos;)
          resolve(newSubscription)
        }
        const raw = protobuf.SubscribeToStream.fromObject({
          eventStreamId: stream.id,
          resolveLinkTos
        })
        this.sendCommand(
          newSubscription.id,
          EventstoreCommand.SubscribeToStream,
          Buffer.from(protobuf.SubscribeToStream.encode(raw).finish()),
          credentials,
          {
            resolve: resolveFunction,
            reject
          }
        )
      }
    )
  }

  /**
   * Unsubscribes from stream
   * @param subscriptionId
   * @returns from stream
   */
  public async unsubscribeFromStream(subscriptionId: string): Promise&lt;void&gt; {
    const subscription = this.subscriptionList.get(subscriptionId)
    if (!subscription) {
      throw eventstoreError.newImplementationError(
        `Can not unsubscribe - subscription ${subscriptionId} not found`
      )
    }
    const subscriptionList = this.subscriptionList
    await new Promise(
      (resolve, reject): void =&gt; {
        const resolveFunction = (): void =&gt; {
          subscription.isSubscribed = false
          subscriptionList.delete(subscriptionId)
          resolve()
        }
        this.sendCommand(
          subscription.id,
          EventstoreCommand.UnsubscribeFromStream,
          null,
          subscription.getCredentials,
          {
            resolve: resolveFunction,
            reject
          }
        )
      }
    )
  }

  /**
   * Emit general low level connection errors (communication errors).
   * Will not emit errors on business level
   *
   * @protected
   * @param {Error} [err]
   * @memberof TCPConnection
   */
  protected onError(err?: Error): void {
    let errorMessage
    let error = err ? err : eventstoreError.newConnectionError(&apos;Eventstore connection error&apos;)

    if (error.name === &apos;Error&apos;) {
      error = eventstoreError.newConnectionError(error.message, err)
    }
    this.log.error({err: error}, errorMessage)
    this.emit(&apos;error&apos;, error)
  }

  /**
   * Emit as soon as connection to eventstore was established successfull
   *
   * @protected
   * @memberof TCPConnection
   */
  protected onConnect(): void {
    this.log.debug(&apos;Connected to eventstore&apos;)
    this.state = connectionState.connected
    this.emit(&apos;connected&apos;)
  }

  /**
   * Emitted as soon as data arrives over tcp connection
   * @param data
   */
  protected onData(data: Buffer | null): void {
    while (data != null) {
      if (this.messageData === null) {
        data = this.handleNewResponseData(data)
      } else {
        data = this.handleMultiPacketResponseData(data)
      }
    }
  }

  /**
   * Emit as soon as connection to eventstore is closed
   *
   * @protected
   * @memberof TCPConnection
   */
  protected onClose(): void {
    this.log.debug(&apos;Connection to eventstore closed&apos;)
    this.state = connectionState.closed
    if (this.heartBeatCheckInterval) {
      clearInterval(this.heartBeatCheckInterval)
    }
    this.emit(&apos;close&apos;)
    if (this.isUnexpectedClosed) {
      this.emit(&apos;error&apos;, eventstoreError.newConnectionError(&apos;Connection closed unexpected&apos;))
    }
  }

  /**
   * Emit when connection starts draining
   */
  protected onDrain(): void {
    this.log.debug(&apos;Eventstore connection draining&apos;)
    this.state = connectionState.drain
    this.emit(&apos;drain&apos;)
  }

  /**
   * Emit when connection secured
   */
  protected onSecureConnect(): void {
    this.log.debug(&apos;Eventstore connection secured&apos;)
    this.emit(&apos;secureConnect&apos;)
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
